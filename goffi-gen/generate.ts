import {
  quicktype,
  InputData,
  JSONSchemaInput,
  FetchingJSONSchemaStore,
} from "quicktype-core";

import { promises as fs } from "fs";

interface FFIPackage {
  in: any;
  out: any;
}

interface FFISpec {
  packages: Record<string, Record<string, FFIPackage>>;
  errorSchema: any;
}

const leadingComments = [
  ``,
  `This file has been autogenerated by goffi-gen. DO NOT EDIT IT MANUALLY!`,
  ``,
];

async function generateErrorInterface(ffiSpec: FFISpec, outputPath: string) {
  const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore());
  await schemaInput.addSource({
    name: `StakError`,
    schema: JSON.stringify(ffiSpec.errorSchema),
  });
  const inputData = new InputData();
  inputData.addInput(schemaInput);
  const renderResult = await quicktype({
    inputData,
    leadingComments: leadingComments,
    lang: "typescript",
    rendererOptions: {
      "explicit-unions": "true",
    },
  });
  await fs.writeFile(
    outputPath,
    renderResult.lines.join("\n")
  );
}

async function main() {
  console.log(`goffi-gen`);
  console.log(`---------`);

  const outputDirectory = "../src";

  console.log(`Parsing goffi-spec.json file...`);
  const ffiSpecContent = await fs.readFile("./goffi-spec.json", "utf8");
  const ffiSpec = JSON.parse(ffiSpecContent) as FFISpec;

  const numberOfModules = Object.keys(ffiSpec.packages).length;
  console.log(`Found ${numberOfModules} modules. Generating code...`);

  // create packages directory, copy static files, generate error interface file
  await fs.mkdir(`${outputDirectory}/packages`, { recursive: true });

  await fs.copyFile(`static/lib.ts`, `${outputDirectory}/lib.ts`);
  console.log(`Copied static file: ${outputDirectory}/lib.ts`);
  
  await generateErrorInterface(ffiSpec, `${outputDirectory}/error.ts`);
  console.log(`Generated error interface file: ${outputDirectory}/error.ts`);
  
  // generate code for each declared package
  for (const packageName in ffiSpec.packages) {
    const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore());
    const bottomExtraLines = [];

    // add import helper function
    bottomExtraLines.push(`import { callNativeFunction } from "../lib";`);
    bottomExtraLines.push(`import { Convert as ErrorConvert } from "../error";`);
    bottomExtraLines.push(``);

    // generate code for each declared function within package
    const packageSpec = ffiSpec.packages[packageName];
    for (let funcName in packageSpec) {
      // add JSON schemas for In and Out parameters
      const funcSpec = packageSpec[funcName];
      await schemaInput.addSource({
        name: `${funcName}In`,
        schema: JSON.stringify(funcSpec.in),
      });
      await schemaInput.addSource({
        name: `${funcName}Out`,
        schema: JSON.stringify(funcSpec.out),
      });

      // generate function
      const funcNameFormatted = funcName.charAt(0).toUpperCase() + funcName.substring(1);
      bottomExtraLines.push(
        `function ${funcName}(args: ${funcNameFormatted}In): Promise<${funcNameFormatted}Out> {`
      );
      bottomExtraLines.push(`  return new Promise((resolve, reject) => {`);
      bottomExtraLines.push(`    const argsJsonStr = Convert.${funcName}InToJson(args);`);
      bottomExtraLines.push(`    const resultJsonStr = callNativeFunction("${packageName}", "${funcName}", argsJsonStr);`);
      bottomExtraLines.push(`    try {`);
      bottomExtraLines.push(`      resolve(Convert.to${funcNameFormatted}Out(resultJsonStr));`);
      bottomExtraLines.push(`    } catch {`);
      bottomExtraLines.push(`      reject(ErrorConvert.toStakError(resultJsonStr));`);
      bottomExtraLines.push(`    }`);
      bottomExtraLines.push(`  });`);
      bottomExtraLines.push(`}`);
      bottomExtraLines.push(``);
    }

    // add exporting generated functions
    bottomExtraLines.push(`export const ${packageName} = {`)
    for (let funcName in packageSpec) {
      bottomExtraLines.push(`  ${funcName},`);
    }
    bottomExtraLines.push(`}`)

    // render types from JSON schema
    const inputData = new InputData();
    inputData.addInput(schemaInput);

    const renderResult = await quicktype({
      inputData,
      leadingComments: leadingComments,
      lang: "typescript",
      rendererOptions: {
        "explicit-unions": "true",
      },
    });

    // add extra lines at the bottom and create file
    renderResult.lines.push(...bottomExtraLines);

    // save file
    await fs.writeFile(
      `${outputDirectory}/packages/${packageName}.ts`,
      renderResult.lines.join("\n")
    );

    console.log(`Generated module file: ${outputDirectory}/packages/${packageName}.ts`);
  }

  // generate index.ts file with package exports
  const indexLines = leadingComments.map(line => `// ${line}`);
  indexLines.push('');
  for (const packageName in ffiSpec.packages) {
    indexLines.push(`export { ${packageName} } from "./packages/${packageName}";`);
  }
  await fs.writeFile(
    `${outputDirectory}/index.ts`,
    indexLines.join("\n")
  );
  console.log(`Generated index file: ${outputDirectory}/index.ts`);

  console.log(`---------`);
  console.log(`SUCCESS`);
}

main();
